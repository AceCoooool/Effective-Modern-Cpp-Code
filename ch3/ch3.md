# ch3. 转向现代C++

## 条款7. 在创建对象时注意区分()和{}

- 大括号初始化可以应用的语境最为宽泛，且可以阻止隐式窄化类型转换（宽化不阻止）。还对解析语法免疫（指的是函数声明还是创建对象可能引起的歧义）
- 在构造函数重载期间，只要有任何可能，大括号初始化就会与`std::initializer_list`类型的形参相匹配，即使其他重载版本有着更加匹配的形参表。（**这点请多留意**）
- 使用小括号还是大括号，会造成大相径庭结果的例子为：使用连个实参来创建`vector<int>`对象 --- `vector<int> a(3, 2)`: 对应3个元素，每个均为2； `vector<int> a{3, 2}`: 对应2个元素，分别为3和2。（说实话，这些在文档里面都写得很清楚了，一般不会出错）
- 在用模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。

> 作者给出的建议是：选择()或{}并坚持下去

## 条款8. 优先选用nullptr，而非0或NULL

其实可以说的更绝对一点：不要用0或NULL代表空指针，请用nullptr

- 0和NULL都不具备指针类型（因此不能作为指针参数）
- 避免在整型和指针类型之间重载（如：`void func(int)`和`void func(void *)` --- 其实都是为了照顾0或NULL的情况）

> nullptr实际类型为`nullptr_t`，且类型`nullptr_t`可以隐式转换到所有的裸指针类型！

## 条款9. 优先选用别名声明(using)，而非typedef

- `typedef`不支持模板化，但别名声明(`using`)支持（`typedef`需要封装到类中来实现模板化）
- 别名模板可以让人避免写`::type`后缀，并且在模板内，对于内嵌`typedef`的引用经常要求加上`typename`前缀（这是因为依赖名导致的---可以详见[typename](http://feihu.me/blog/2014/the-origin-and-usage-of-typename/))）

> 在C++11中很多模板别名还是利用`typedef`获得的，因此经常需要加上`typename`。（C++14都有对应的别名模板了），但可以对C++11中的情况采用下述方式：
>
> ```cpp
> template<class T>
> using remove_const_t = typename remove_const<T>::type
> ```

## 条款10. 优先选用限定作用域的枚举类型，而非不限作用域的枚举类型

> 还是坚持只用限定作用域的枚举类型吧，主要优点：
>
> - 降低命名空间污染
> - 强类型的
> - 可以进行前置声明

限定作用域的枚举类型：`enum class Color{black, white, red};`

不限定作用域的枚举类型：`enum Color{black, white, red};`

- C++98风格的枚举类型，现在称为不限定范围的枚举类型
- 限定作用域的枚举类型仅在枚举类内可见。它们只能通过强制类型转换转换到其他类型
- 限定作用域的枚举类型和不限定范围的枚举类型都支持底层类型指定（例如：`enum Class Status: uint32_t`或者`enum Status: uint32_t`）。限定作用域的枚举类型的默认底层类型是int，而不限范围的枚举类型没有默认底层类型
- 限定作用域的枚举类型总是可以进行前置声明，而不限范围的枚举类型却只有在指定了默认底层类型的前提下才可以进行前置声明

## 条款11. 优先选用删除函数(=delete)，而非private未定义函数

- 优先选用删除函数（`=delete`），而非private来未定义函数
- 任何函数都可以删除，包括非成员函数和模板实现

> 反正请都使用=delete吧，忘了private的方式～

