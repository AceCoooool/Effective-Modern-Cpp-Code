# ch5. 右值引用、移动语义和完美转发

- **移动语义**使得编译器得以使用不那么昂贵的移动操作来替换昂贵的复制操作。同复制构造函数、复制赋值运算符给予人们控制对象复制的具体意义的能力一样，移动构造函数和移动赋值运算符也给予人们控制对象移动语义的能力。移动语义也使得创建只移类型对象成为可能，这些类型包括std::unique_ptr，std::future和std::thread等
- **完美转发**使得人们可以撰写接受任意实参的函数模板，并将其转发到其他函数，目标函数会接受到与转发函数所接受的完全相同的实参

右值引用是将这两个风马牛不相及的语言特性胶合起来的底层语言机制，正是它使得移动语义和完美转发成为了可能。

> **形参总是左值，即使其类型是右值引用**：如`void f(Widget&& w)`中的w是左值

## 条款23. 理解std::move和std::forward

- std::move实施的是无条件的向右值类型的**强制类型转换**。就其本身而言，它不会执行移动操作
- 仅当传入的实参被绑定到右值时，std::forward才针对该实参实施向右值类型的**强制类型转换**
- 在运行期，std::move和std::forward都不会做任何操作！


> ① std::move只做一件事情，就是把实参强制转换成右值（它做的是强制类型转换，而不是移动）
>
> ② 如果想取得某个对象执行移动操作的能力，则不要将其声明为常量，因为针对常量对象执行的移动操作将一声不响地变换成复制操作（由于构造函数"匹配"的缘故）；std::move不仅不实际移动任何东西，甚至不保证经过其强制类型转换后的对象具备可移动的能力，唯一可以确定的是该结果会是个右值

## 条款24. 区分万能引用和右值引用

- 如果函数模板形参具备`T&&`类型，并且`T`的类型是推导而来或者对象使用`auto &&`声明其类型，则该形参或对象就是个万能引用
- 如果类型声明并不精确地具备`type &&`的形式，或者类型推导并未发生，则`type &&`就代表右值引用
- 若采用右值来初始化万能引用，就会得到一个右值引用。若采用左值来初始化万能引用，就会得到一个左值引用。

> ① 若要使引用成为**万能引用**，涉及类型推导是必要条件，但还不是充分条件。其形式必须正好形如`T &&`才行，例如一个const就会"剥夺"了成为万能引用的资格：
>
> ```cpp
> template<typename T>
> void f(const T && param)   // param是个右值引用---因为const
> ```
>
> ② "位于模板内"并不能保证"一定涉及类型推导"，例如下述的例子（因为实例的类型`vector_own<int>`就完全决定了push_back的声明类型）
>
> ```cpp
> template<class T, class Allocator=allocator<T>>
> class vector_own {
> public:
>     // rvalue reference
>     void push_back(T &&x) {
>         cout << type_id_with_cvr<decltype(x)>().pretty_name() << endl;
>     }
> }
> ```
>
> ③ 区分右值引用和万能引用有助于使你能够更精确地读懂代码

## 条款25. 针对右值引用实施std::move，针对万能引用实施std::forward

- 针对**右值引用**的最后一次使用实施std::move，针对**万能引用**的最后一次使用实施std::forward
- 作为**按值返回**的函数的右值引用和万能引用，依上一条所述采取相同行为
- 若局部对象(例如函数内部声明的变量)可能适用于返回值优化，则请勿针对其实施std::move或std::forward

> ① 依左值和右值的重载会导致"代码膨胀"(其实就是写的多=。=)以及降低运行效率，但最大的问题是这种设计的可扩展性很差（尤其在参数量很多的时候）
>
> ② 若你想要在单一函数内将某个对象**不止一次**地绑定到右值引用或者万能引用，而且你想保证完成对该对象的其他所有操作之前，其值不被移走。在这种情况下，你就得仅在最后一次使用该引用时对其实施std::move或者std::forward
>
> ③ **按值返回**的函数中，如果返回的是**绑定到一个右值引用或一个万能引用的对象**，则当你返回该引用时，应该对其实施std::move或者std::forward
>
> ④ 针对函数中按值返回的**局部对象**实施std::move是个馊主意！！！它不能给编译器帮上忙，却可能会帮倒忙（可能会排除掉RVO---return value optimization的实施机会）

## 条款26. 避免用万能引用类型进行重载

- 把万能引用作为重载候选类型，几乎总会让该重载版本在始料未及的情况下被调用到
- 完美转发构造函数的问题尤为严重，因为对于非常量的左值类型而言，它们一般都会形成相对于复制构造函数的更佳的匹配，并且它们还会**劫持派生类中对基类的复制和移动构造函数的调用**

> ① 形参为万能引用的函数，是C++中最贪婪的。这就是为什么把重载和万能引用这两者结合起来几乎总是馊主意！一旦万能引用成为重载候选，他就会吸引走大批的实参类型，远比撰写重载代码的程序员期望的要多
>
> ② 若在函数调用时，一个模板实例化函数和一个非函数模板（即一个"常规函数"）具备相等的匹配程度，则优先选用**常规函数**

## 条款27. 熟悉用万能引用类型进行重载的替代方案

- 如果不使用万能引用和重载的组合，则替代方案包括使用彼此不同的函数名字，传递`const T&`类型的形参，传值和标签分派
- 经由`std::enable_if`对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件
- 万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势

> ① 使用传递左值常量引用类型来代替传递万能指针引用类型：这种方式的缺点是达不到我们想要的高效率
>
> ② 标签分配：通过一个"含标签"的函数来调用不同重载版本的函数，运用"标签"强制重载决议按我们想要的方向推进，只有标签值才决定了调用的是哪个重载版本
>
> ③ "砍掉"万能引用的"部分"函数模板：形如`template<typename T, typename=enable_if_t<condition>>`，里面的条件很多都会有一些库函数的"if判断"（例如`is_base_of<类型1, 类型2>`---类型2是否是类型1的继承类）
>
> ④ 万能引用转发的次数越多，某些地方出错时给出的错误信息就越让人摸不着头脑，可以用`static_assert`和`is_constructible`在编译期间判定具备某个类型的对象是否从另一类型的对象出发完成构造

## 条款28. 理解引用折叠

- 引用折叠会在四种语境中发生：模板实例化，auto类型生成，创建和运用typedef和别名声明，以及decltype
- 当编译器在引用折叠的语境下生成引用的引用时，结果会变成单个引用。如果原始的引用中有任一引用为左值引用，则结果为左值引用。否则，结果为右值引用
- 万能引用就是在类型推导的过程会区别左值和右值，以及会发生引用折叠的语境中的右值引用

> ① "引用的引用"是非法的！
>
> ② 四种可能的引用组合（左值-左值，左值-右值，右值-左值，右值-右值）：如果任一引用为左值引用，则结果为左值引用；否则结果为右值引用
>
> ③ 万能引用并非一种新的引用类型，其实它就是满足了下面两个条件语境中的右值引用：
>
> - 类型推导过程中区别左值和右值：T类型的左值推导结果为`T &`，而T类型的右值则推导结果为T
> - 会发生引用折叠

## 条款29. 假定移动操作不存在，成本高，未使用

**说明：大部分情况下移动操作还是更高效的哦！！！**

- 假定移动操作不存在，成本高，未使用
- 对于那些类型或对于移动语义的支持情况已知的代码，则无需做以上假定

> ① 大部分标准容器都是将其内容存放在堆上（用指针指向堆内存），但std::array类型的对象的内容数据是直接存储在对象内的（并不用指针指向）；所有std::array的复制和移动成本几乎一样
>
> ② 许多string的实现都采用了小型字符串优化（SSO）--- "小型"字符串会存储在string对象内的某个缓冲区内，而不去使用堆上分配的内存。从而对于小型字符串实施移动并不比复制快

## 条款30. 熟悉完美转发的失败情形

- 完美转发的失败情形，是源于模板类型推导失败，或推导结果是错误的类型
- 会导致完美转发失败的实参种类有：大括号初始化物，以值0或NULL表达的空指针，仅有声明的整型static const成员变量，模板或重载的函数名字，以及位域

> ① 论及一般意义上的转发时，都是在处理形参为引用类型的情形
>
> ② 引用这东西，在编译器生成的机器代码中，通常是当指针来处理的（这也是为什么仅声明而未定义的static const成员变量无法进行转发的原因）
>
> ③ 如果想让实施完美转发的函数接受重载函数名字或者模板名字，只有手动指定需要转发的那个版本或者实例
>
> ```cpp
> // 版本1
> int processVal(int value) {
>     cout << "process(int)" << endl;
>     return 0;
> }
> // 版本2
> int processVal(int value, int priority) {
>     cout << "process(int, int)" << endl;
>     return 0;
> }
> // 手动指定采用版本1
> using FuncType = int (*)(int);
> FuncType processPtr = processVal;
> ```
>
> ④ 非const引用不得绑定到位域：可以使转发目的函数接收的总是位域值的副本～