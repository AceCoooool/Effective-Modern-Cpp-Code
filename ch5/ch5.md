# ch5. 右值引用、移动语义和完美转发

- **移动语义**使得编译器得以使用不那么昂贵的移动操作来替换昂贵的复制操作。同复制构造函数、复制赋值运算符给予人们控制对象复制的具体意义的能力一样，移动构造函数和移动赋值运算符也给予人们控制对象移动语义的能力。移动语义也使得创建只移类型对象成为可能，这些类型包括std::unique_ptr，std::future和std::thread等
- **完美转发**使得人们可以撰写接受任意实参的函数模板，并将其转发到其他函数，目标函数会接受到与转发函数所接受的完全相同的实参

右值引用是将这两个风马牛不相及的语言特性胶合起来的底层语言机制，正是它使得移动语义和完美转发成为了可能。

> 形参总是左值，即使其类型是右值引用：如`void f(Widget && w)`中的w是左值

## 条款23：理解std::move和std::forward

- std::move实施的是无条件的向右值类型的**强制类型转换**。就其本身而言，它不会执行移动操作
- 仅当传入的实参被绑定到右值时，std::forward才针对该实参实施向右值类型的**强制类型转换**
- 在运行期，std::move和std::forward都不会做任何操作！


## 条款24：区分万能引用和右值引用

- 如果函数模板形参具备`T&&`类型，并且`T`的类型是推导而来或者对象使用`auto &&`声明其类型，则该形参或对象就是个万能引用
- 如果类型声明并不精确地具备`type &&`的形式，或者类型推导并未发生，则`type &&`就代表右值引用
- 若采用右值来初始化万能引用，就会得到一个右值引用。若采用左值来初始化万能引用，就会得到一个左值引用。

> ① 若要使引用称为万能引用，涉及类型推导是必要条件，但还不是充分条件。其形式必须正好形如`T &&`才行，例如一个const"剥夺"了成为万能引用的资格：
>
> ```cpp
> template<typename T>
> void f(const T && param)   // param是个右值引用---因为const
> ```
>

## 条款25：针对右值引用实施std::move，针对万能引用实施std::forward

- 针对右值引用的最后一次使用实施std::move，针对万能引用的最后一次使用实施std::forward
- 作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行为
- 若局部对象(例如函数内部声明的变量)可能适用于返回值优化，则请勿针对其实施std::move或std::forward

## 条款26：避免用万能引用类型进行重载

- 把万能引用作为重载候选类型，几乎总会让该重载版本在始料未及的情况下被调用到
- 完美转发构造函数的问题尤为严重，因为对于非常量的左值类型而言，它们一般都会形成相对于复制构造函数的更佳的匹配，并且它们还会劫持派生类中对基类的复制和移动构造函数的调用

## 条款27：熟悉用万能引用类型进行重载的替代方案

- 如果不使用万能引用和重载的组合，则替代方案包括使用彼此不同的函数名字，传递`const T&`类型的形参，传值和标签分派
- 经由`std::enable_if`对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件
- 万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势

## 条款28：理解引用折叠

- 引用折叠会在四种语境中发生：模板实例化，auto类型生成，创建和运用typedef和别名声明，以及decltype
- 当编译器在引用折叠的语境下生成引用的引用时，结果会变成单个引用。如果原始的引用中有任一引用为左值引用，则结果为左值引用。否则，结果为右值引用
- 万能引用就是在类型推导的过程会区别左值和右值，以及会发生引用折叠的语境中的右值引用

## 条款29：假定移动操作不存在，成本高，未使用

- 假定移动操作不存在，成本高，未使用
- 对于那些类型或对于移动语义的支持情况已知的代码，则无需做以上假定

## 条款30：熟悉完美转发的失败情形

- 完美转发的失败情形，是源于模板类型推导失败，或推导结果是错误的类型
- 会导致完美转发失败的实参种类有大括号初始化物，以值0或NULL表达的空指针，仅有声明的整型static const成员变量，模板或重载的函数名字，以及位域