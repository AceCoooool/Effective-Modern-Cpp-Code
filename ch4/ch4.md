# ch4. 智能指针

裸指针存在的问题：

1. 裸指针在声明中并没有指出，裸指针指涉到的是单个对象还是一个数组
2. 裸指针在声明中也没有提示在使用完指涉的对象以后，是否需要析构它。换言之，你从声明中看不出来指针是否拥有其指涉的对象
3. 即使知道需要析构指针所指涉的对象，也不可能知道如何析构才是适当的。是应该使用delete运算符呢，还是采用其他方式（比如，可能需要把指针传入一个专门的，用于析构的函数）
4. 即使知道了应该使用delete运算符，根据1可知，还是会发生到底应该用单个对象形式（delete）还是数组形式（delete[]）的疑问。一旦用错，就会导致未定义行为
5. 即使启用够确信，指针拥有其指涉的对象，并且也知道应该如何析构，要保证析构在所有代码路径上都仅只执行一次（包括那些导致异常的路径）仍然困难重重。只要少在一条路径上执行，就会导致内存泄露。而如果析构在一条路径上执行了多于一次，则会导致未定义行为
6. 没有什么正规的方式能检测出指针是否空悬，也就是说，它指涉的内存是否已经不在持有指针本应该指涉的对象。如果一个对象已经被析构了，而某些指针仍然会指涉到它，就会产生空悬指针

## 条款18：使用std::unique_ptr管理具备专属所有权的资源

- std::unique_ptr是小巧，高速的，具备只移类型（不能复制，只能move操作）的智能指针，对托管资源实施专属所有权语义。
- 默认地，资源析构采用delete运算符来实现，但可以指定自定义删除器。有状态的删除其和采用函数指针实现的删除器会增加std::unique_ptr类型的对象尺寸。（尽可能采用Lambda形式）
- 将std::unique_ptr转换成std::shared_ptr是容易实现的

## 条款19：使用std::shared_ptr管理具备共享所有权的资源

- std::shared_ptr提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收
- 与std::unique_ptr相比，std::shared_ptr的尺寸通常是裸指针尺寸的两倍，它还会带来控制块的开销，并要求原子化的引用计数操作
- 默认的资源析构通过delete运算符进行，但同时也支持定制删除器。删除器的类型对std::shared_ptr的类型没有影响（std::unique_ptr定制的删除器是类型相关的---`unique_ptr<类型，decltype<删除器函数>> p(nullptr, 删除器函数)`，std::shared_ptr则是类型无关的---`share_ptr<类型> p(指针，删除器函数)`）
- 避免使用裸指针类型的变量来创建std::shared_ptr指针（容易导致创建多个控制块）

## 条款20：对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr

- 使用std::weak_ptr来代替可能空悬的std::shared_ptr
- std::weak_ptr可能的用武之地包括缓存，观察者列表，以及避免std::shared_ptr指针环路


## 条款21：优先选用std::make_unique和std::make_shared，而非直接使用new

- 相比于直接使用new表达式，make系列函数消除了重复代码，改进了异常安全性，并且对于std::make_shared和std::allocate_shared而言，生成的目标代码会尺寸更小，速度更快
- 不适于使用make系列函数的场景包括需要定制删除器，以及期望直接传递大括号初始物
- 对于std::shared_ptr，不建议使用make系列函数的额外场景包括：① 自定义内存管理的类；② 内存紧张的系统，非常大的对象以及存在比指涉到相同对象的std::shared_ptr生存期更久的std::weak_ptr

## 条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放在实现文件中

> ① Pimpl：pointer to implementation
>
> ② 特殊成员函数指的的：构造函数，析构函数，复制，移动（放到此类的实现文件：xxx.cpp文件中---否则可能会出现错误）

- Pimpl惯用法通过降低类的客户和类实现者之间的依赖性，减少了构建遍数
- 对于采用std::unique_ptr来实现的pImpl指针，必须在类的头文件中声明特种成员函数，但在实现文件中实现它们。即使默认函数实现默认有着正确的行为，也必须这么做
- 上述建议仅适用于std::unique_ptr，但并不适用std::shared_ptr

