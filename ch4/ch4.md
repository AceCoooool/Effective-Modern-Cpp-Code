# ch4. 智能指针

裸指针存在的问题：

1. 裸指针在声明中并没有指出，裸指针指涉到的是单个对象还是一个数组
2. 裸指针在声明中也没有提示在使用完指涉的对象以后，是否需要析构它。换言之，你从声明中看不出来指针是否拥有其指涉的对象
3. 即使知道需要析构指针所指涉的对象，也不可能知道如何析构才是适当的。是应该使用delete运算符呢，还是采用其他方式（比如，可能需要把指针传入一个专门的，用于析构的函数）
4. 即使知道了应该使用delete运算符，根据1可知，还是会发生到底应该用单个对象形式（delete）还是数组形式（delete[]）的疑问。一旦用错，就会导致未定义行为
5. 即使启用够确信，指针拥有其指涉的对象，并且也知道应该如何析构，要保证析构在所有代码路径上都仅只执行一次（包括那些导致异常的路径）仍然困难重重。只要少在一条路径上执行，就会导致内存泄露。而如果析构在一条路径上执行了多于一次，则会导致未定义行为
6. 没有什么正规的方式能检测出指针是否空悬，也就是说，它指涉的内存是否已经不在持有指针本应该指涉的对象。如果一个对象已经被析构了，而某些指针仍然会指涉到它，就会产生空悬指针

## 条款18：使用std::unique_ptr管理具备专属所有权的资源

- std::unique_ptr是小巧，高速的，具备只移类型（不能复制，只能move操作）的智能指针，对托管资源实施专属所有权语义。
- 默认地，资源析构采用delete运算符来实现，但可以指定自定义删除器。有状态的删除其和采用函数指针实现的删除器会增加std::unique_ptr类型的对象尺寸。（尽可能采用Lambda形式）
- 将std::unique_ptr转换成std::shared_ptr是容易实现的

## 条款19： 使用std::shared_ptr管理具备共享所有权的资源

- std::shared_ptr提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收
- 与std::unique_ptr相比，std::shared_ptr的尺寸通常是裸指针尺寸的两倍，它还会带来控制块的开销，并要求原子化的引用计数操作
- 默认的资源析构通过delete运算符进行，但同时也支持定制删除器。删除器的类型对std::shared_ptr的类型没有影响（std::unique_ptr定制的删除器是类型相关的---`unique_ptr<类型，decltype<删除器函数>> p(nullptr, 删除器函数)`，std::shared_ptr则是类型无关的---`share_ptr<类型> p(指针，删除器函数)`）
- 避免使用裸指针类型的变量来创建std::shared_ptr指针（容易导致创建多个控制块）

## 条款20：对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr

- 使用std::weak_ptr来代替可能空悬的std::shared_ptr
- std::weak_ptr可能的用武之地包括缓存，观察者列表，以及避免std::shared_ptr指针环路